---
tags:
  - 算法
  - 数组
  - C语言
时间: 2026-02-13T17:32:00
---

已知两个**升序**数组，输出一个升序数组，并且包含两个已知数组的所有数据。
* 解法一（也是我第一次写出来的解法）
  ```c
    #include <stdio.h>
	int main()
	{
	    int n, m;
	    scanf("%d %d", &n, &m);
	    int arr1[n], arr2[m], final[m + n];
	    for (int i = 0;i < n;i++)
	    {
	        scanf("%d ", &arr1[i]);
	    }
	    for (int i = 0;i < m;i++)
	    {
	        scanf("%d ", &arr2[i]);
	    }
	    for (int i = 0;i < n + m;i++)
	    {
	        if (i < n)
	        {
	            final[i] = arr1[i];
	        }
	        else
	        {
	            final[i] = arr2[i - n];
	        }
	    }
	    for (int i = 0;i < m + n;i++)
	    {
	        for (int j = i;j < m + n;j++)
	        {
	            if (final[i] > final[j])
	            {
	                int tem = final[i];
	                final[i] = final[j];
	                final[j] = tem;
	            }
	        }
	    }
	    for (int i = 0;i < m + n;i++)
	    {
	        printf("%d ", final[i]);
	    }
	    return 0;
	}
  ```
  > [!tips]
  > 虽然也能解决问题，但是完全没有用到两个升序数组的条件，属于是暴力算法，对于少量数据还行，一旦数据过多，就会遇到问题。
* 优化方案：
  核心思想，双指针归并法。
	* 分别用指针i，j指向两个序列的起始位置
	* 比较arr1[i]和arr2[j]，将较小者放入结果数组。
	* 移动较小值对应的指针。
	* 重复步骤2，3，直到一个序列遍历完
	* 将另一个序列的剩余元素全部追加到结果数组中
	* 代码实现如下：
  ```c
	#include <stdio.h>
	int main() 
	{
	    int n, m;
	    scanf("%d %d", &n, &m);
	    int a[n], b[m];
	    for (int i = 0; i < n; i++) scanf("%d ", &a[i]);
	    for (int i = 0; i < m; i++) scanf("%d ", &b[i]);
	
	    int res[n + m];
	    int i = 0, j = 0, k = 0;
	    while (i < n && j < m) 
	    {
	        if (a[i] <= b[j]) res[k++] = a[i++];
	        else res[k++] = b[j++];
	    }
	    while (i < n) res[k++] = a[i++];
	    while (j < m) res[k++] = b[j++];
	
	    for (int i = 0; i < n + m; i++) 
	    {
		    printf("%d ", res[i]);
		 }
	    return 0;
   }
  ```
  